---
title: "NBA Shot Project"
author: "Chris Williams"
date: "August 20, 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, echo=FALSE}
```

```{r package}
library(tidyverse)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

```{r read_data}
shots <- read_csv("nba_shots.csv")
summary(shots)
str(shots)
shots <- shots %>% mutate(player_name = map_chr(shots$player_name, str_to_title))
totals <- read_csv("totals_1415.csv")
str(totals)
into_names <- names(totals) %>% str_split(",") %>% .[[1]]
names(totals) <- "x"
totals <- totals %>% separate(x, into_names, sep = ",")
totals <- as_tibble(totals)
head(totals)
positions <- totals %>% select(c("Player", "Pos"))
```

```{r explore_data_positions}
##need lubridate because GAME_CLOCK is time
library(lubridate)
summary(positions)
nrow(positions) - n_distinct(positions$Player) #duplicate players from being on different teams
n_distinct(positions$Pos) #will need to handle this later, there are dual positions
#Keeping only distinct players because I just want position info
positions <- positions %>% distinct(Player, .keep_all = TRUE)
sum(is.na(positions$Player))
positions[which(is.na(positions$Player)),]
positions <- positions %>% drop_na() %>% mutate(rid = row_number())
##dropped a reference line of where the data came from while adding a row id number "unique identifier"
#checking to see what characters are part of player column
unique(unlist(str_split(positions$Player, "")))
positions[str_which(positions$Player, "\\\\.*"),]
## "\\appears before some kind of id name for all players so I want to remove this and the id name"
positions$Player <- str_replace_all(positions$Player, "\\\\.*", "")
#accent marks are not represented so index these
bad_char <- positions[str_which(positions$Player, "[\\?\uFFFD]"),]
#after a quick view, "?" at the end is a "c"
positions$Player <- if_else(str_detect(positions$Player, "\\?$"), str_replace(positions$Player, "\\?$", "c"), positions$Player)
#index what is remaining and there isn't any real overlap to allow for an effective ifelse...
bad_char_remain <- positions[str_which(positions$Player, "[\\?\uFFFD]"),]
fixed_pname <- c("Alexis Ajinca", "Omer Asik", "Jose Calderon", "Francisco Garcia", "Manu Ginobili", "Jorge Gutierrez", "Nene Hilario", "Ersan Ilyasova", "Donatas Motiejunas", "Damjan Rudez", "Dennis Schroder", "Kevin Seraphin", "Hedo Turkoglu", "Jonas Valanciunas", "Anderson Varejao", "Greivis Vasquez", "Nikola Vucevic")
positions$Player <- plyr::mapvalues(positions$Player, from = bad_char_remain$Player, to = fixed_pname)
#check what characters remain
unique(unlist(str_split(positions$Player, "")))
#fix players with multiple positions
positions[str_which(positions$Pos, ".{3,}"),]
positions$Pos <- str_replace_all(positions$Pos, "^(..)-(..)$", "\\1")
#although position does not guarentee height, speed, etc..., greater "distance" between the positions of shooters and defenders should represent "mismatch" scenarios.
#prepare for merging
positions <- rename(positions, "player_name" = "Player")
```
###now move onto shots...
```{r explore_data_shots}
n_distinct(shots$player_name)
player_list_shooter <- shots %>% distinct(player_name)
no_match_shots <- player_list_shooter %>% anti_join(positions, by = "player_name")
fixed_pname_2 <- c("Joe Ingles", "DeMarre Carroll", "Jimmer Fredette", "Monta Ellis", "J.J. Barea", "Al-Farouq Aminu", "Dirk Nowitzki", "Kyle O'Quinn", "LeBron James", "C.J. Watson", "C.J. Miles", "Danilo Gallinari", "J.J. Hickson", "P.J. Tucker", "Nerlens Noel", "K.J. McDaniels", "JaKarr Sampson", "Luc Mbah a Moute", "O.J. Mayo", "Beno Udrih", "Amar'e Stoudemire", "Tim Hardaway", "D.J. Augustin", "Dwyane Wade", "Ray McCallum", "Ben McLemore", "DeMarcus Cousins", "Steven Adams", "J.J. Redick", "DeAndre Jordan", "CJ McCollum", "LaMarcus Aldridge", "Allen Crabbe", "Zach LaVine")
shots$player_name <- plyr::mapvalues(shots$player_name, from = no_match_shots$player_name, to = fixed_pname_2)
#check the success of the join
shots %>% distinct(player_name) %>% anti_join(positions, by = "player_name")
#check some data quality starting with
#ranges
shots_ranges <- map(shots, ~range(.))
#NAs
shots_na <- map(shots, ~sum(is.na(.))) %>% unlist()
#shot_clock is the only column with NAs
#persumably these are mostly situations in which the shot clock is off (i.e., end of quarters)
shots_ranges$GAME_CLOCK
#time difference in seconds, but parsed as hours, minutes, seconds
#game clock is measured within quarter (would need to pair with period to get game time across quarters)
shots <- shots %>% mutate(qtr_seconds = (seconds(GAME_CLOCK)/60))
shots %>% filter(qtr_seconds > 24 & is.na(SHOT_CLOCK))
#clearly many instances in which shot clock data is missing and is NOT the end of a quarter
#it is possible that these situations represent "immediate" putbacks or shots off of rebounds when shot clock gets reset (but shot clock should still be recorded) or shots off of turnovers or shots "launched" from across court
shots %>% filter(is.na(SHOT_CLOCK) & qtr_seconds > 24 & TOUCH_TIME <= 1) %>% nrow(.)
#this would "save" 783 shots/rows of data by allowing for no reset of the shot clock on a "fast" rebound+shot or a loose ball and then fast shot
#could also filter by dribbles b/c shot clock should have time to reset when dribble is greater than zero or 1
shots %>% filter(is.na(SHOT_CLOCK) & qtr_seconds > 24 & TOUCH_TIME <= 1 & DRIBBLES >= 1) %>% group_by(DRIBBLES) %>% tally()
#there are 14 such cases but because touch time is less than or equal to 1 and dribbles is not greater than 1 (which would suggest an error in the data) these cases can be kept
#but lets look at what those "fast" shots are like
shots %>% filter(is.na(SHOT_CLOCK) & qtr_seconds > 24 & TOUCH_TIME <= 1) %>%
  ggplot(aes(SHOT_DIST)) +
  geom_freqpoly()
#the distribution of fast shots seems to match that of all shots in terms of shot distance
#what about the others that don't seem to fit within a "fast" shot
shots %>% filter(is.na(SHOT_CLOCK) & qtr_seconds > 24 & TOUCH_TIME > 1)
shots %>% filter(is.na(SHOT_CLOCK) & qtr_seconds > 24 & TOUCH_TIME > 1) %>% group_by(player_name) %>% tally() %>% arrange(desc(`n`))
#this isn't an issue for one player or group of players, almost all players 
shots %>% filter(is.na(SHOT_CLOCK) & qtr_seconds > 24 & TOUCH_TIME > 1) %>%
  ggplot(aes(SHOT_DIST)) +
  geom_freqpoly()
#dropping all of these would be over 1200 shots
shots <- shots %>% filter(!(qtr_seconds > 24 & is.na(SHOT_CLOCK) & TOUCH_TIME > 1))
#now the NAs can be replaced with a "shot clock" vlaue based on game clock if needed
#may not want to do this yet with end of quarter, shot clock "off" shots, but can do it for "fast shots" assigning a 24 when appropriate 
shots[is.na(shots$SHOT_CLOCK) & shots$qtr_seconds > 24, 9] <- 24
shots_ranges$TOUCH_TIME
#a touch time of 0 isn't necessarily an error if it is measured as touch time other than shooting
#because there was no description of what touch time represents I will explore
#negative touch time is not possible and must be an error and should be dropped (lose over 300 shots)
shots %>% filter(TOUCH_TIME < 0) %>% nrow(.)
shots <- shots %>% filter(TOUCH_TIME >= 0)
shots %>% filter(TOUCH_TIME == 0)
shots %>% filter(TOUCH_TIME == 0 & DRIBBLES > 0)
#only a couple of instances where dribble is more than 1, but only 10 instances total
#the 1 dribbles will remain because those are "realistic" based on game time, shot clock, etc...
#the 2 and 3 dribble cases will be dropped
shots <- shots %>% filter(!(TOUCH_TIME == 0 & DRIBBLES > 1))
#IF going to replace with mean
###shots %>% filter(TOUCH_TIME > 0) %>% group_by(DRIBBLES) %>% summarize(ave_tt = mean(TOUCH_TIME), sd_tt = sd(TOUCH_TIME), cnt = n()) %>% filter(cnt > 40)
#knn imputation would be
#library(VIM)
#shots$TOUCH_TIME[shots$TOUCH_TIME <= 0 & shots$DRIBBLES > 0] <- NA
#shots <- kNN(shots, variable = "TOUCH_TIME") but this does not take care of the large number of 0s
#touch time should never be negative and the 3000 or so 0s is concerning if it supposed to include shooting time;
##however those probably represent tips or catch and shoot situations
#could also used the means like in the line above, but knn produces consistently lower values and sd tends to be greater than 1 but around 1.15-1.35 for each dribble
########
#########
#drop shots that aren't "realistic" or consistent with pts type
#all shots are within length of the court
shots_ranges$SHOT_DIST
shots %>% filter(PTS_TYPE == 3 & SHOT_DIST < 21.5)
#shots <- shots %>% filter(!(PTS_TYPE == 3 & SHOT_DIST < 21.5)) or just recode them to twos
shots %>% count(SHOT_DIST > 40)
shots %>% count(SHOT_DIST == 0)
#JUST DROP shot dist that equall 0
#shots <- shots %>% filter(SHOT_DIST < 40)
#
#fix defender names
coms <- str_which(shots$CLOSEST_DEFENDER, ",")
all <- row_number(shots$CLOSEST_DEFENDER)
no_coms <- setdiff(all, coms)
unique(shots[no_coms, 15])
shots$CLOSEST_DEFENDER <- str_replace(shots$CLOSEST_DEFENDER, "Nene", "Hilario, Nene")
defend <- str_split(shots$CLOSEST_DEFENDER, ", ")
  nms <- c("last_name", "first_name")
  defenddf <- data_frame(map_chr(defend, 1),
                       map_chr(defend, 2)) %>%
    setNames(nms) %>%
    mutate(player_name = str_c(first_name, last_name, sep = " "))
  anti_join(defenddf, positions, by = "player_name") %>% distinct(player_name)
  ###drop atila dos santos shots - no proof he played
no_match_defenders <- anti_join(defenddf, positions, by = "player_name") %>% distinct(player_name) %>% filter(player_name != "Atila Dos Santos")
fixed_pname_def <- c("J.J. Barea", "C.J. Miles", "C.J. Watson", "J.J. Hickson", "Tim Hardaway", "J.J. Redick", "P.J. Tucker", "K.J. McDaniels", "C.J. Wilcox", "P.J. Hairston", "Jeffery Taylor", "Luigi Datome", "Chuck Hayes", "Glen Rice", "T.J. Warren", "Toure' Murry")
defenddf$player_name<- plyr::mapvalues(defenddf$player_name, from = no_match_defenders$player_name, to = fixed_pname_def)
shots <- shots %>% filter(CLOSEST_DEFENDER != "Dos Santos, Atila")
defend1 <- str_split(shots$CLOSEST_DEFENDER, ", ")
shots <- shots %>% mutate(last_name = map_chr(defend1, 1), first_name = map_chr(defend1, 2))
shots$CLOSEST_DEFENDER <- str_c(shots$first_name, shots$last_name, sep = " ")
shots$CLOSEST_DEFENDER<- plyr::mapvalues(shots$CLOSEST_DEFENDER, from = no_match_defenders$player_name, to = fixed_pname_def)
#####now join positions to defender names
anti_join(shots, positions, by = c("CLOSEST_DEFENDER" = "player_name")) %>% select(CLOSEST_DEFENDER)

#dup_def <- shots %>% group_by(CLOSEST_DEFENDER, CLOSEST_DEFENDER_PLAYER_ID) %>% count()
#dup_def$CLOSEST_DEFENDER[duplicated(dup_def$CLOSEST_DEFENDER)]
#quincy pondexterhas two assigned ids
#dup_shooter <- shots %>% group_by(player_name, player_id) %>% count()
#dup_shooter$player_name[duplicated(dup_shooter$player_name)]
#no duplicated shooters
shots_updated <- shots %>% left_join(positions, by = "player_name") %>% left_join(positions, by = c("CLOSEST_DEFENDER" = "player_name")) %>% rename("POS_DEF" = "Pos.y", "POS_SHOOTER" = "Pos.x", "rid_DEF" = "rid.y", "rid_SHOOTER" = "rid.x")
#
#recoded the names without a match then ensured that the join was successful
#
# will need to do this shots <- shots %>% mutate_if(is.character, as.factor)
```
#some exploratory visualizations and alterations
```{r exploratory visualizations}
library(cowplot)
index1 <- map_lgl(shots, is.numeric)
names12 <- names(shots[, index1])
plot_lst <- list()
for(i in names12){
  plt <- ggplot(shots, aes_string(x=i)) +
    geom_histogram()
  plot_lst[[i]] <- plt
}
cowplot::plot_grid(plotlist = plot_lst, nrow = 4)
map(plot_lst, print)
#most games are close with bimodal around 0, some "step" patter in number of shots, very few overtime games, relatively normal distr of shot clock with many at 24 (likely off rebounds), most dribbles under 5 short touch time, shots seem to match "modern" nba with most either close or far with relatively few midrange, doesn't seem to be data error in reporting pts type (at least in putting a number other than 2 or 3), most shots occur with a defender with 5 or so feet, fgm is either 1 or 0
colnames(shots[, !index1])
```
